import { JSON参数解析插件, 常用接口返回器, 接口, 接口逻辑 } from '@lsby/net-core'
import { Right } from '@lsby/ts-fp-data'
import { z } from 'zod'

// =======================
// 接口逻辑组合 - 展示
// =======================
// 这个示例展示了:
// - "接口逻辑组合"是什么
// - "接口逻辑组合"和"插件"的区别
// - 完整的"接口逻辑组合"的写法
//
// 注意:
// 在这个示例中, 以教学为目的, 写了复杂的泛型类型
// 在实际使用中, 这些类型是可以自动推导的, 其他的示例中会使用更简单的写法

// =======================
// 接口逻辑组合
// =======================
// 通过"绑定"方法, 可以将多个"接口逻辑"串联在一起, 形成一个新的"接口逻辑"
// 每个"接口逻辑"都可以选择返回"左值"或"右值", 左值会作为返回数据立即返回, 右值则会被合并到"逻辑附加参数"里
// 下游的"接口逻辑"可以拿到"逻辑附加参数", 新的接口逻辑的结果也是最终的"逻辑附加参数"

// =======================
// 与插件的的区别
// =======================
// 接口逻辑组合 和 插件 存在一定程度上的重叠, 二者是区别是:
// - "插件"是"接口逻辑"的组成部分, 可以访问req/res原始对象, 主要用于处理HTTP层面的细节, 带有副作用
// - "接口逻辑"是业务层面的逻辑, 而"接口逻辑组合"是复用"接口逻辑"的一种方法, 主要用于业务逻辑编排

let 接口路径 = '/api/composition/simple' as const
let 接口方法 = 'post' as const

// 第一个接口逻辑
// 这个接口逻辑的行为是, 获得 body 参数, 打印日志, 并直接返回参数
let 参数解析逻辑 = 接口逻辑.构造(
  [new JSON参数解析插件(z.object({ x: z.number() }), {})],
  async (参数, _逻辑附加参数, 请求附加参数) => {
    let log = 请求附加参数.log

    let { x } = 参数.body
    await log.info('获取参数: x=%d', x)

    return new Right({ x })
  },
)

// 第二个接口逻辑
// 这个逻辑将 x 加 5
// 出于教学目的, 本例中分开定义每个接口逻辑
// 为了能正确获取到逻辑附加参数的类型, 这里必须手动提供泛型参数
// 在实际业务中, 可以通过内联方式自动推导类型, 在其他的示例中会演示这些简单的写法
// 接口逻辑的泛型参数是:
// - 插件类型: 插件们的类型, 本例中, 这个接口逻辑不需要参数, 所以是空数组
// - 附加逻辑参数: 附加逻辑参数的类型, 本例中, 这个接口逻辑要求上游提供一个叫x的数字值
// - 错误类型: 业务逻辑错误时的类型, 本例中, 这个接口不会出错
// - 正确类型: 业务逻辑正确时的类型, 本例中, 这个接口会返回一个叫result的数字值
let 加五逻辑 = 接口逻辑.构造<[], { x: number }, never, { result: number }>(
  [],
  async (_参数, 逻辑附加参数, _请求附加参数) => {
    let { x } = 逻辑附加参数
    return new Right({ result: x + 5 })
  },
)

// 第三个接口逻辑
// 这个逻辑将结果乘以 2
// 同样, 需要手动标注泛型
let 乘以二逻辑 = 接口逻辑.构造<[], { result: number }, never, { result: number }>(
  [],
  async (_参数, 逻辑附加参数, _请求附加参数) => {
    let { result } = 逻辑附加参数
    return new Right({ result: result * 2 })
  },
)

// 将逻辑组合的方法是, 使用"绑定"方法
// 如果下游的"逻辑附加参数类型"和上游的"返回类型"不匹配, 就会报错
let _组合逻辑 = 参数解析逻辑.绑定(加五逻辑).绑定(乘以二逻辑)
// 也可以用更链式的写法
let 组合逻辑 = 接口逻辑.空逻辑().绑定(参数解析逻辑).绑定(加五逻辑).绑定(乘以二逻辑)

let 接口返回器 = new 常用接口返回器(z.never(), z.object({ result: z.number() }))

export default new 接口(接口路径, 接口方法, 组合逻辑, 接口返回器)
