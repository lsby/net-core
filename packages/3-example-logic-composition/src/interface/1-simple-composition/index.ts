import { JSON参数解析插件, 常用结果转换器, 常用结果返回器, 接口, 接口逻辑 } from '@lsby/net-core'
import { Right } from '@lsby/ts-fp-data'
import { z } from 'zod'

// =======================
// 接口逻辑组合
// =======================
// 通过 绑定 方法, 可以将多个逻辑串联在一起, 形成一个新的逻辑
// 上游接口逻辑 的 返回值, 会被深度合并到 逻辑附加参数 里, 供下游的所有接口逻辑使用
//
// 接口逻辑组合 和 插件 存在一定程度上的重叠, 二者是区别是:
// - 插件 是 接口逻辑 的组成部分, 可以访问 req/res 原始对象, 主要用于 处理 HTTP 层面的细节
// - 接口逻辑 是 业务层面的逻辑, 而 接口逻辑组合 是复用 接口逻辑 的一种方法, 主要用于 业务逻辑编排
//
// 这个示例展示了最基本的逻辑组合:
// 1. 第一步: 获取参数 (x)
// 2. 第二步: 加 5
// 3. 第三步: 乘以 2

let 接口路径 = '/api/composition/simple' as const
let 接口方法 = 'post' as const

// 第一个接口逻辑
// 这个接口逻辑的行为是, 获得 body 参数, 打印日志, 并直接返回参数
let 参数解析逻辑 = 接口逻辑.构造(
  [new JSON参数解析插件(z.object({ x: z.number() }), {})],
  async (参数, _逻辑附加参数, 请求附加参数) => {
    let log = 请求附加参数.log

    let { x } = 参数.body
    await log.info('获取参数: x=%d', x)

    return new Right({ x })
  },
)

// 第二个接口逻辑
// 这个逻辑将 x 加 5
// 因为演示考虑, 这里是分开定义两个接口逻辑的
// 为了能正确获取到逻辑附加参数, 这里必须手动提供泛型
// 泛型参数:
// - 插件类型
// - 上游接口逻辑的返回类型
// - 当前接口逻辑的错误类型
// - 当前接口逻辑的返回类型
// 接口的 逻辑附加参数 是上游接口的返回值
let 加五逻辑 = 接口逻辑.构造<[], { x: number }, never, { result: number }>(
  [],
  async (_参数, 逻辑附加参数, _请求附加参数) => {
    let { x } = 逻辑附加参数
    return new Right({ result: x + 5 })
  },
)

// 第三个接口逻辑
// 这个逻辑将结果乘以 2
// 类型也是一样, 需要手动标注泛型
let 乘以二逻辑 = 接口逻辑.构造<[], { result: number }, never, { result: number }>(
  [],
  async (_参数, 逻辑附加参数, _请求附加参数) => {
    let { result } = 逻辑附加参数
    return new Right({ result: result * 2 })
  },
)

// 将逻辑组合的方法是, 使用 绑定 方法
// 如果下游的 接口逻辑 的 逻辑附加参数类型 和 上游的 返回类型 不匹配, 会报错
let _组合逻辑 = 参数解析逻辑.绑定(加五逻辑).绑定(乘以二逻辑)

// 也可以用更链式的写法
let 组合逻辑 = 接口逻辑.空逻辑().绑定(参数解析逻辑).绑定(加五逻辑).绑定(乘以二逻辑)

let 结果转换器 = new 常用结果转换器(z.never(), z.object({ result: z.number() }))
let 结果返回器 = new 常用结果返回器()

export default new 接口(接口路径, 接口方法, 组合逻辑, 结果转换器, 结果返回器)
