import {
  JSON参数解析插件,
  常用接口返回器,
  接口,
  接口逻辑,
  计算接口逻辑JSON参数,
  计算接口逻辑正确结果,
  计算接口逻辑错误结果,
} from '@lsby/net-core'
import { Right } from '@lsby/ts-fp-data'
import { z } from 'zod'
import { 缓存逻辑 } from '../../interface-logic/cache-logic'

// =======================
// 通用缓存逻辑示例
// =======================
// 这个示例展示了:
// - 接口逻辑组合的理念和理论
// - 编写并演示了业务无关的接口逻辑(缓存)的用法

// =======================
// 理念
// =======================
// "接口逻辑组合"的主要的用途是:
// - 出错时提前返回左值
// - 注入能力供下游使用

// =======================
// 理论
// =======================
// 接口逻辑的返回值是Either, "绑定"方法则是在其上实现的一个类monad算子
//
// 考虑这样的代码:
//
// ```typescript
// 接口逻辑.空逻辑()
//   .绑定(A)
//   .绑定(B) // B中可以调用A的返回结果
//   .绑定(C) // C中可以调用A和B的返回结果
// ```
//
// 这类似于:
//
// ```haskell
// do
//   a <- A
//   b <- B // B中可以调用a
//   c <- C // C中可以调用a和b
//   pure {a, b, c}
// ```
//
// 注意: 上面的A, B, C的结果皆为Either, 如果返回左值, 后续过程将直接被跳过

// =======================
// 拼乐高
// =======================
// 可以通过参数将"接口逻辑"和实际业务完全解耦, 其甚至可以被发成npm包, 因为它和实际业务完全无关, 可以实现跨项目复用
// 可以想象, 当这种"接口逻辑"足够多时, 开发接口就变成组合这些逻辑的"拼乐高"游戏
// 并且它们的组合是类型安全的, 类型系统会检查连接处的类型是否匹配

// =======================
// 复用性和代数效应
// =======================
// 推荐抽象通用组件, 并构造纯代数效应链:
//
// 考虑这样的代码:
//
// ```typescript
// 接口逻辑.空逻辑()
//   .绑定(用户鉴权)      // 通用, 可通过参数与业务解耦, 实现跨项目复用
//   .绑定(缓存)          // 通用, 可通过参数与业务解耦, 实现跨项目复用
//   .绑定(限流)          // 通用, 可通过参数与业务解耦, 实现跨项目复用
//   .绑定(业务相关逻辑)  // 业务相关逻辑, 但不触发副作用, 而是返回"描述副作用的数据"
//   .绑定(操作数据库)    // 业务相关逻辑, 解析"描述副作用的数据", 并实际执行
// ```
//
// 这样的好处是:
// - 跨项目复用的逻辑块
// - 业务逻辑可以保持是纯的, 非常方便独立测试

let 接口路径 = '/api/composition/user-with-cache' as const
let 接口方法 = 'post' as const

let 查询参数类型描述 = z.object({ userId: z.string() })
let 预期返回类型描述 = z.object({ 用户id: z.string(), 姓名: z.string(), 邮箱: z.string(), 创建时间: z.string() })
type 用户信息类型 = z.infer<typeof 预期返回类型描述>

let 接口逻辑实现 = 接口逻辑
  .空逻辑()
  // 这里绑定了一个"缓存逻辑", 它完全与业务解耦
  // 一旦绑定了这个接口逻辑, 它就会提供这些能力:
  // - 缓存数据: 如果命中缓存, 会得到缓存数据, 否则会得到null
  // - 设置缓存: 用来设置缓存
  .绑定(new 缓存逻辑(查询参数类型描述, 预期返回类型描述, 10 * 1000))
  .绑定(
    接口逻辑.构造([new JSON参数解析插件(查询参数类型描述, {})], async (参数, 逻辑附加参数, 请求附加参数) => {
      let log = 请求附加参数.log

      // 如果缓存命中, 可以在这里直接用缓存数据返回
      if (逻辑附加参数.缓存数据 !== null) return new Right({ 用户数据: 逻辑附加参数.缓存数据 })

      // 否则, 读取数据
      let { userId } = 参数.body

      // 模拟用户数据库
      let 用户库: Record<string, 用户信息类型> = {
        'user-001': { 用户id: 'user-001', 姓名: '张三', 邮箱: 'zhangsan@example.com', 创建时间: '2024-01-01' },
        'user-002': { 用户id: 'user-002', 姓名: '李四', 邮箱: 'lisi@example.com', 创建时间: '2024-01-02' },
        'user-003': { 用户id: 'user-003', 姓名: '王五', 邮箱: 'wangwu@example.com', 创建时间: '2024-01-03' },
      }

      let 用户数据 = 用户库[userId]
      if (用户数据 === void 0) {
        await log.warn('用户不存在: %s', userId)
        // 因为 ts 无法将 null 推断为 X | null, 所以需要手动标注
        return new Right({ 用户数据: null as 用户信息类型 | null })
      }

      // 正确取到数据, 设置缓存
      逻辑附加参数.设置缓存(用户数据)
      await log.info('查询用户成功: %s', userId)

      return new Right({ 用户数据: 用户数据 })
    }),
  )

type _接口逻辑JSON参数 = 计算接口逻辑JSON参数<typeof 接口逻辑实现>
type _接口逻辑错误返回 = 计算接口逻辑错误结果<typeof 接口逻辑实现>
type _接口逻辑正确返回 = 计算接口逻辑正确结果<typeof 接口逻辑实现>

let 接口返回器 = new 常用接口返回器(z.never(), z.object({ 用户数据: 预期返回类型描述.or(z.null()) }))

export default new 接口(接口路径, 接口方法, 接口逻辑实现, 接口返回器)
