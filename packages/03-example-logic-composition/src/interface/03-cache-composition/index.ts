import {
  JSON参数解析插件,
  常用接口返回器,
  接口,
  接口逻辑,
  计算接口逻辑JSON参数,
  计算接口逻辑正确结果,
  计算接口逻辑错误结果,
} from '@lsby/net-core'
import { Right } from '@lsby/ts-fp-data'
import { z } from 'zod'
import { 缓存逻辑 } from '../../interface-logic/cache-logic'

// =======================
// 通用缓存逻辑示例
// =======================
// 这个示例展示了:
// - 接口逻辑组合的理念和理论
// - 编写并演示了业务无关的接口逻辑(缓存)的用法

// =======================
// 理念
// =======================
// "接口逻辑组合"的主要的用途是:
// - 出错时提前返回左值
// - 注入能力供下游使用

// =======================
// 理论
// =======================
// 接口逻辑的返回值是Either, "绑定"方法则是在其上实现的一个类monad算子
//
// 考虑这样的代码:
//
// ```typescript
// 接口逻辑.空逻辑()
//   .绑定(A)
//   .绑定(B) // B中可以调用A的返回结果
//   .绑定(C) // C中可以调用A和B的返回结果
// ```
//
// 这类似于:
//
// ```haskell
// do
//   a <- A
//   b <- B // B中可以调用a
//   c <- C // C中可以调用a和b
//   pure {a, b, c}
// ```
//
// 注意: 上面的A, B, C的结果皆为Either, 如果返回左值, 后续过程将直接被跳过

// =======================
// 拼乐高
// =======================
// 可以通过参数将"接口逻辑"和实际业务完全解耦, 其甚至可以被发成npm包, 因为它和实际业务完全无关, 可以实现跨项目复用
// 可以想象, 当这种"接口逻辑"足够多时, 开发接口就变成组合这些逻辑的"拼乐高"游戏
// 并且它们的组合是类型安全的, 类型系统会检查连接处的类型是否匹配

// =======================
// 复用性和代数效应
// =======================
// 推荐抽象通用组件, 并构造纯代数效应链:
//
// 考虑这样的代码:
//
// ```typescript
// 接口逻辑.空逻辑()
//   .绑定(用户鉴权)      // 通用, 可通过参数与业务解耦, 实现跨项目复用
//   .绑定(缓存)          // 通用, 可通过参数与业务解耦, 实现跨项目复用
//   .绑定(限流)          // 通用, 可通过参数与业务解耦, 实现跨项目复用
//   .绑定(业务相关逻辑)  // 业务相关逻辑, 但不触发副作用, 而是返回"描述副作用的数据"
//   .绑定(操作数据库)    // 业务相关逻辑, 解析"描述副作用的数据", 并实际执行
// ```
//
// 这样的好处是:
// - 跨项目复用的逻辑块
// - 业务逻辑可以保持是纯的, 非常方便独立测试

// =======================
// 极低的设计门槛
// =======================
// 虽然"通用接口逻辑"听起来需要精心的设计, 但**在这个架构下并非如此**
// 由于接口逻辑之间是正交的, 且下游依赖上游, 我们可以非常随意的设计通用逻辑, 类型系统会确保契约可靠
//
// 得益于强类型契约, 我们认为:
// - 再强的抽象也无法适配未来所有可能的变化, 所以我们选择拥抱变化
// - 不要惧怕膨胀, 因为现实本就是无限复杂的, 膨胀是不可避免的, 而我们追求的是对膨胀的管理
//
// 因此: 只要能满足当前的需求, 它就是合格的通用逻辑
//
// 这样做有很多优势:
// - 你不需要想破脑袋写一个100个参数的上帝组件
// - 如果未来某个逻辑不满足需求了, 不需要修改它(可能破坏旧代码), 只需要复制并修改出一份新的逻辑即可, 旧的业务继续使用旧的逻辑, 新的业务使用新的逻辑
// - 当你遇到一个根本看不懂的屎山逻辑时, 不再需要花很久读懂它, 然后小心处理依赖它缺陷的各个逻辑, 只需要从业务上知道它想做什么, 然后写一个新的给新逻辑用即可
// - 这完美符合"开闭原则", 且几乎没有通用的设计成本
//
// 这种模式也存在一些问题, 但现在AI编程取得了长足的进步, 或许这些不再是问题了:
// - 如果原始组件的实现就有bug, 复制出来的组件会将bug也不断复制:
//   - 以前这确实是一个问题, 因为不同的组件产生了不同的变体, 虽然这些变体的本质模式是类似的, 但很难写将其一次性全部替换
//   - 不过, 注意到错误的代码是类似的, 就算无法写出批量替换的逻辑, 至少也可以批量定位到错误的文件, 之后, 让AI修复这些类似的模式即可
// - 可能会出现过多类似的组件, 造成选择困难, 也污染视觉和搜索
//   - 可以通过AI等手段实现"推荐"机制, 这样既预防了不必要的膨胀, 又解决了选择困难
//   - 当组件过多时, 考虑将其抽象为npm包, 将不必要的"藏起来"
// - 出现过多的"僵尸逻辑"
//   - 本质上这并不是一个问题, 只要它能用, 没人在乎它占用几个字节的空间
//   - 这就像是程序依赖, 即使新版本推出, 旧版本也不会被删除, 也允许有软件依赖旧版本
//   - 当真的有空的时候(通常不会有这种时候), 处理这些僵尸逻辑, 确认影响范围, 小心重构, 仔细测试
//
// 软件的本质是工具, 正确性应当大于美观性

let 接口路径 = '/api/composition/user-with-cache' as const
let 接口方法 = 'post' as const

let 查询参数类型描述 = z.object({ userId: z.string() })
let 预期返回类型描述 = z.object({ 用户id: z.string(), 姓名: z.string(), 邮箱: z.string(), 创建时间: z.string() })
type 用户信息类型 = z.infer<typeof 预期返回类型描述>

let 接口逻辑实现 = 接口逻辑
  .空逻辑()
  // 这里绑定了一个"缓存逻辑", 它完全与业务解耦
  // 一旦绑定了这个接口逻辑, 它就会提供这些能力:
  // - 缓存数据: 如果命中缓存, 会得到缓存数据, 否则会得到null
  // - 设置缓存: 用来设置缓存
  .绑定(new 缓存逻辑(查询参数类型描述, 预期返回类型描述, 10 * 1000))
  .绑定(
    接口逻辑.构造([new JSON参数解析插件(查询参数类型描述, {})], async (参数, 逻辑附加参数, 请求附加参数) => {
      let log = 请求附加参数.log

      // 如果缓存命中, 可以在这里直接用缓存数据返回
      if (逻辑附加参数.缓存组件.缓存数据 !== null) return new Right({ 用户数据: 逻辑附加参数.缓存组件.缓存数据 })

      // 否则, 读取数据
      let { userId } = 参数.json

      // 模拟用户数据库
      let 用户库: Record<string, 用户信息类型> = {
        'user-001': { 用户id: 'user-001', 姓名: '张三', 邮箱: 'zhangsan@example.com', 创建时间: '2024-01-01' },
        'user-002': { 用户id: 'user-002', 姓名: '李四', 邮箱: 'lisi@example.com', 创建时间: '2024-01-02' },
        'user-003': { 用户id: 'user-003', 姓名: '王五', 邮箱: 'wangwu@example.com', 创建时间: '2024-01-03' },
      }

      let 用户数据 = 用户库[userId]
      if (用户数据 === void 0) {
        await log.warn('用户不存在: %s', userId)
        // 因为 ts 无法将 null 推断为 X | null, 所以需要手动标注
        return new Right({ 用户数据: null as 用户信息类型 | null })
      }

      // 正确取到数据, 设置缓存
      逻辑附加参数.缓存组件.设置缓存(用户数据)
      await log.info('查询用户成功: %s', userId)

      return new Right({ 用户数据: 用户数据 })
    }),
  )

type _接口逻辑JSON参数 = 计算接口逻辑JSON参数<typeof 接口逻辑实现>
type _接口逻辑错误返回 = 计算接口逻辑错误结果<typeof 接口逻辑实现>
type _接口逻辑正确返回 = 计算接口逻辑正确结果<typeof 接口逻辑实现>

let 接口返回器 = new 常用接口返回器(z.never(), z.object({ 用户数据: 预期返回类型描述.or(z.null()) }))

export default new 接口(接口路径, 接口方法, 接口逻辑实现, 接口返回器)
