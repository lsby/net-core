import {
  JSON参数解析插件,
  常用接口返回器,
  接口,
  接口逻辑,
  计算接口逻辑JSON参数,
  计算接口逻辑正确结果,
  计算接口逻辑错误结果,
} from '@lsby/net-core'
import { Right } from '@lsby/ts-fp-data'
import { z } from 'zod'

// =======================
// 加法接口
// =======================
// 这个示例是一个完整的入门说明, 展示了:
// - 框架的核心概念
// - 框架的基本写法
//
// 注意:
// - 在这个示例中, 出于教学为目的, 写的相对繁琐
// - 在实际使用中, 写法会简化, 其他的示例中会使用更简单的写法

// =======================
// 执行过程
// =======================
// 请求 -> 插件 -> 业务逻辑 -> 接口返回器 -> 客户端
//         ----------------
//            接口逻辑
//         ------------------------------
//                      接口

// =======================
// 概念
// =======================
//  插件: 负责从HTTP上下文中获取信息, 供业务逻辑使用, 是副作用
//  业务逻辑: 业务的核心算法, 应当尽可能是纯函数
//  接口逻辑: 是"插件 + 业务逻辑"的组合, 独立存在, 既可以用于构成接口, 又可以作为函数直接调用
//  - 将其作为接口的组成部分时, 插件会自动执行, 负责从HTTP上下文中提取参数
//  - 将其作为函数调用时, 会绕过插件, 而原本插件提供的参数, 将需要在调用时提供, 有类型检查
//  接口返回器: 是"接口"的组成部分, 描述如何将"业务逻辑"返回的Either值返回给客户端
//  接口: 描述一个HTTP接口, 是"基本信息(路径, 方法) + 业务逻辑 + 接口返回器"的组合

// --------------------
// 1. 定义插件
// --------------------
// "插件"是"业务逻辑"的前置过程
// 在执行"业务逻辑"前, 会依次先执行对应的"插件"们
// 每个"插件"都有返回值, "业务逻辑"会收到所有"插件"的返回结果的合并结果
// 本例中, 实例化了内置的"JSON解析参数插件", 该插件会按给定形式解析请求中的JSON参数, 并将其返回为body字段
let JSON参数解析 = new JSON参数解析插件(z.object({ a: z.number(), b: z.number() }), {})

// --------------------
// 2. 定义接口逻辑
// --------------------
// "接口逻辑"是"接口"的核心逻辑过程
// 构造它需要提供两个参数:
// - 插件数组
// - 业务逻辑
// 其中, "业务逻辑"会获得三个参数:
// - 参数: 所有"插件"的返回值的合并值
// - 逻辑附加参数: 上游的其他"接口逻辑"的返回值, 本例中没有使用
// - 请求附加参数: 请求的相关的对象, 由框架本身提供, 例如 请求id, log 等
// "业务逻辑"必须返回Either值, 左值表示失败, 右值表示成功
let 接口逻辑实现 = 接口逻辑.构造([JSON参数解析], async (参数, 逻辑附加参数, 请求附加参数) => {
  // log是"请求附加参数"给出的快捷日志句柄, 可以用来输出日志
  // 同时也包含一些高级功能, 但本例中不演示
  let log = 请求附加参数.log

  // "参数.body"是"JSON参数解析插件"提供的解析结果, 是类型安全的
  let { a, b } = 参数.body

  // 日志模块会自带请求id, 一般使用时只需要简单打印即可
  await log.info('执行加法运算: %d + %d', a, b)

  // 正确结果用右值返回
  return new Right({ result: a + b })
})

// 可以通过类型计算, 直观的看到"接口逻辑"的各种信息
type _接口逻辑JSON参数 = 计算接口逻辑JSON参数<typeof 接口逻辑实现>
type _接口逻辑错误返回 = 计算接口逻辑错误结果<typeof 接口逻辑实现>
type _接口逻辑正确返回 = 计算接口逻辑正确结果<typeof 接口逻辑实现>

// --------------------
// 3. 定义接口返回器
// --------------------
// "接口返回器"决定如何将"接口逻辑"返回的Either值返回给请求者
// 本例中, 使用内置的"常用接口返回器", 它的逻辑是:
// - 如果是左值, 使用 res.send 返回 { status: 'fail', data: ... }
// - 如果是右值, 使用 res.send 返回 { status: 'success', data: ... }
// 构建该返回器时, 需要提供两个参数:
// - 实现错误类型Zod: 即"接口逻辑"错误时的类型表示, 本例中, 接口逻辑不会产生任何错误, 所以使用 z.never()
// - 实现正确类型Zod: 即"接口逻辑"正确时的类型表示, 本例中, 接口逻辑会返回 { result: number } 类型的数据, 所以使用 z.object({ result: z.number() })
let 接口返回器 = new 常用接口返回器(z.never(), z.object({ result: z.number() }))

// --------------------
// 4. 定义接口
// --------------------
// 最后, 将一切组合起来
// 推荐将接口作为默认导出, 以配合自动化脚本
let 接口路径 = '/api/calculate-add' as const
let 接口方法 = 'post' as const
export default new 接口(接口路径, 接口方法, 接口逻辑实现, 接口返回器)

// 接口逻辑可以被复用, 只需导出即可
// 在其他例子中将使用这个导出
export let 加法接口 = 接口逻辑实现
