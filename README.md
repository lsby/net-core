# Net-Core

一个基于 TypeScript 的**强类型**、**函数式**后端框架。

> **代码即文档**: 本框架不提供文字文档，而是通过示例项目讲解概念和使用方法。精确的类型定义和自解释的代码才是最准确的文档。

## 🎯 核心特性

### 类型驱动

- **🛡️ 极致类型安全**: 从请求参数(Params/Body/Query)到响应结果，包括接口调用，甚至 WebSocket 通信，全程享受 TypeScript 自动推导的类型保护。
- **🔒 可控错误处理**: 告别不可预测的 try/catch 和隐式异常抛出。框架强制使用 Either 处理错误，让错误处理成为类型签名的一部分。**你只需要关注逻辑流，编译器会强制你处理每一个可能的异常**。
- **🔍 强类型上下文**: 严禁传统中间件的“隐式挂载”。所有由插件提供的数据必须通过类型明确传递，确保**全链路上下文类型安全**，数据来源一目了然。

### 模块化架构

- **🧩 副作用隔离**: 将逻辑过程严格拆分，插件（副作用） -> 业务逻辑（纯逻辑） -> 返回器（协议适配），实现真正的解耦，拒绝大面条代码。
- **⚡ 逻辑两用性**: 接口逻辑既能作为 HTTP 接口运行，又能像普通函数一样被直接调用。这意味着核心逻辑可以**轻松移植、内部复用、独立测试**。
- **🧹 自动清理器**: 接口逻辑内置清理代理。无论是逻辑正常结束、中途出错、还是异常崩溃，框架保证触发清理逻辑（如关闭连接、释放文件、审计写入），杜绝资源泄露。

### 代码复用

- **🧱 可组合性**: 允许类 Monad 模式组合多个接口逻辑，能力正交组合，在类型安全加持下，**实现可替换的，跨项目级逻辑复用**。
- **🔌 混合通道**: 框架内置 WebSocket 能力, 可与 HTTP 接口**共用同一套鉴权、逻辑与错误处理模型**。同一个接口逻辑既能处理 HTTP 请求，又能通过相同上下文进行实时推送，无需编写两套入口点。

### 工程优化

- **🔄 前后端类型同步**: 基于 **TypeScript 编译器 API** 进行真正的静态分析，一键生成前端可用的类型定义，后端接口变更自动同步到前端。**再也不会出现接口文档过期、前后端类型不一致的问题**。
- **🧪 测试友好**: 支持 **Co-location 测试**（测试文件与业务代码同目录），自动生成测试脚手架，极大降低测试成本。
- **🔗 生态兼容**: 框架底层基于 Express，开发者可以通过编写插件以提供类型，在确保**全链路上下文类型安全**的前提下，复用现有的 Express 中间件（如 CORS, Helmet 等）。
- **🛟 逃生舱**: 返回器可以拿到原始的 `req`/`res` 句柄，**在需要完全的 Express 灵活性时，可以绕过框架的约束，直接使用 Express 的任何 API**。
- **🤖 自动化工具链**: 内置 CLI 工具链，自动生成 API 索引、类型文件、单元测试脚手架。

## 🪄 类型生成和调用

![类型生成和调用](./doc/type-generate-and-call.gif)

## 🏗️ 生产级实战

**如果你想看如何在生产环境中使用本框架, 构建大型应用（包含 全局状态, 数据库集成, 文件上传, JWT 鉴权, WebSocket 机制应用, CRUD 组合器 等）, 请参考作者的完全体项目模版:**

👉 **[lsby/playground-ts-service](https://github.com/lsby/playground-ts-service)**

## 🚀 快速开始

### 1. 环境准备

确保已启用 `pnpm`。

### 2. 编译核心

```bash
cd packages/core
pnpm i
npm run _build:all
```

### 3. 运行示例

进入任意示例目录（例如 `packages/01-example-base`），运行开发命令：

## 📂 代码结构

本仓库采用 Monorepo 结构：

### 核心库

- **[core](./packages/core)**: 框架的本体实现，包含了服务器、插件系统、逻辑运行时及自动化工具。

### 学习路径

请按顺序阅读以下示例，逐步掌握框架使用：

1.  **[01-example-base](./packages/01-example-base)**: 核心概念入门。学习如何定义一个最基本的接口，理解“插件”、“逻辑”、“返回器”的协作。
2.  **[02-example-plugins](./packages/02-example-plugins)**: 插件系统详解。学习如何使用内置插件（如 JSON解析）以及如何编写自定义插件。
3.  **[03-example-logic-composition](./packages/03-example-logic-composition)**: 进阶业务编排。学习如何复用逻辑单元，使用组合串联复杂的业务流程。
4.  **[04-example-web-socket](./packages/04-example-web-socket)**: WebSocket 机制示例。
5.  **[05-example-test](./packages/05-example-test)**: 单元测试机制。学习如何使用框架提供的工具进行高效测试。
6.  **[06-example-complex-type-export](./packages/06-example-complex-type-export)**: 复杂类型系统的导出方法。
7.  **[07-example-express-compatibility](./packages/07-example-express-compatibility)**: Express 兼容性示例。学习如何包装 Express 中间件，复用现有生态，实现完全的 Express 兼容模式。
8.  **[08-example-cors](./packages/08-example-cors)**: cors 示例。学习如何通过框架的方式实现 cors。

```bash
cd packages/01-example-base
pnpm dev
# 你的接口现在运行在 http://localhost:3000
```

## 🛠️ 自动化工具链

框架由以下内置 CLI 工具驱动效率：

- `lsby-net-core-gen-api-list`: 自动扫描代码，生成 API 路由索引。
- `lsby-net-core-gen-api-type`: 自动扫描代码，生成前端可用的 TypeScript 类型定义。
- `lsby-net-core-gen-test`: 自动扫描代码，生成单元测试脚手架。

在不同的示例中, 会将这些命令编写为 npm 命令, 请查看示例中的 package.json 来了解详情

## 💡 设计哲学

### 1. 显式责任

> **“自由的代价是责任。”**

框架故意将底层的 `req` 和 `res` 对象藏了起来，无法在业务逻辑中直接访问。这并非功能缺失，而是有意为之的**责任界定**。

- **默认约束**：便利往往伴随着代价。如果直接暴露底层对象，极易导致弱类型的滥用。
- **有代价的自由**：框架并不阻止获取底层控制权，可以编写自定义插件将句柄导出，也可以写自定义返回器。但这需要你编写额外的代码——**这种“麻烦”本身就是一种门槛**。当你跨越这个门槛时，意味着你已经**理解了风险**，并愿意**为此负责**。

### 2. 认知分层

> **“专业的事交给专业的人。”**

框架通过类型系统，将开发工作分层：

- **能力-责任分层**：
  - **基础设施层**（插件/返回器/通用逻辑）：由**资深开发者**编写。这里充满复杂的类型体操和副作用处理，但编写一次即可被无数次复用。
  - **业务实现层**（接口逻辑）：由**业务开发者**甚至 **AI** 编写。这里是类型安全的“沙箱”，开发者只需理解最基本的概念，关注纯粹的业务数据流转，约束及严，心智负担极低。
- **抽象-需求分层**：
  - **框架内（绝大部分）**：常见需求在框架的抽象范围内解决，享受极致的开发体验和类型保护。
  - **框架外（极少部分）**：无法被抽象覆盖的边缘需求，类型保护有限，需要开发者自行掌控风险。

## 📄 开源协议

本项目基于 [MIT](./LICENSE) 协议开源。
