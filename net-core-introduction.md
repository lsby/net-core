---
marp: true
theme: default
size: 16:9
paginate: true
style: |
  section {
    background-color: #1e1e1e;
    color: #ffffff;
  }
  h1, h2, h3, h4 {
    color: #61dafb;
  }
  p, li {
    color: #cccccc;
  }
  code {
    background-color: #2d2d2d;
    color: #f8f8f2;
  }
  pre {
    background-color: #2d2d2d;
    font-size: 0.6em;
    line-height: 1.2;
    max-height: 50vh;
    overflow: auto;
    padding: 10px;
    border-radius: 5px;
  }
  /* 语法高亮样式 */
  .hljs-keyword { color: #569cd6; }
  .hljs-string { color: #ce9178; }
  .hljs-comment { color: #6a9955; font-style: italic; }
  .hljs-number { color: #b5cea8; }
  .hljs-function { color: #dcdcaa; }
  .hljs-type { color: #4ec9b0; }
  .hljs-built_in { color: #4ec9b0; }
  .hljs-title { color: #dcdcaa; }
  .hljs-params { color: #9cdcfe; }
  a {
    color: #4fc3f7;
  }
  table {
    background-color: #2d2d2d;
    color: #ffffff;
  }
  th, td {
    border-color: #555555;
  }
---

# Net-Core

## 一个基于TypeScript的强类型, 函数式后端框架

---

## 🏗️ 架构组成

### 接口定义

```typescript
let 加法逻辑 = 接口逻辑.构造([new JSON参数解析插件(z.object({ a: z.number(), b: z.number() }), {})], async (参数) => {
  let { a, b } = 参数.json // 类型安全
  return new Right({ result: a + b })
})

export default new 接口('/api/add', 'post', 加法逻辑, new 常用接口返回器(z.never(), z.object({ result: z.number() })))
```

### 处理流程

```
请求 → 插件 → 业务逻辑 → 接口返回器 → 客户端
```

### 核心概念

- **插件**: 从HTTP上下文中提取参数(副作用)
- **业务逻辑**: 核心逻辑(尽可能纯)
- **接口返回器**: 决定响应方式(文件流, JSON, 文本等)

---

## ⚡ 逻辑两用性

### 接口逻辑的两种使用方式

```typescript
// 1. 作为HTTP接口使用
export default new 接口('/api/calculate', 'post', 计算逻辑, 返回器)

// 2. 作为普通函数直接调用
let 结果 = await 计算逻辑.调用({ json: { a: 1, b: 2 } })
```

### 两用性优势

- **🚀 轻松移植**: 核心逻辑无需修改即可在不同场景使用
- **🔄 内部复用**: 在同一个应用中复用业务逻辑
- **🧪 独立测试**: 可绕过HTTP层, 直接测试业务逻辑

---

## 🧱 逻辑组合

### 组合多个接口逻辑

```typescript
let 组合逻辑 = 接口逻辑
  .空逻辑()
  .绑定(用户鉴权) // 通用, 可跨项目复用
  .绑定(缓存) // 通用, 可跨项目复用
  .绑定(限流) // 通用, 可跨项目复用
  .绑定(业务相关逻辑) // 业务相关逻辑, 可以使用上面的流程注入的所有能力
```

### 组合优势

- **能力正交组合**: 独立功能模块化组合
- **类型安全**: 组合后仍保持强类型
- **可复用性**: 跨项目复用逻辑

---

## 🌐 WebSocket支持

- HTTP和WebSocket **共用同一套逻辑**
- 相同的鉴权, 错误处理模型
- 实时推送能力

---

## 🛠️ 工程工具

### 类型生成

- **类型生成**: 基于TypeScript编译器API生成类型文件
- **前后端类型同步**: 前端读取类型文件, 再也不会出现前后端信息不一致的问题

### 测试支持

- **Co-location测试**: 支持测试文件与业务代码同目录
- **测试生成**: 自动生成测试文件, 可通过正则筛选

---

## 💡 设计哲学

### 显式责任

> **"自由的代价是责任. "**

框架故意将底层的`req`和`res`对象藏了起来, 无法在业务逻辑中直接访问. 这并非功能缺失, 而是有意为之的**责任界定**.

- **默认约束**: 便利往往伴随着代价. 如果直接暴露底层对象, 极易导致弱类型的滥用.
- **有代价的自由**: 框架并不阻止获取底层控制权, 可以编写自定义插件将句柄导出, 也可以写自定义返回器. 但这需要你编写额外的代码, **这种"麻烦"本身就是一种门槛**. 当你跨越这个门槛时, 意味着你已经**理解了风险**, 并愿意**为此负责**.

---

### 认知分层

> **"专业的事交给专业的人. "**

框架通过类型系统, 将开发工作分层:

- **基础设施层**(插件/返回器/通用逻辑): 由**核心开发者**编写. 这里充满复杂的类型体操和副作用处理, 但编写一次即可被无数次复用.
- **业务实现层**(接口逻辑): 由**初级开发者**甚至 **AI** 编写. 这里是类型安全的"沙箱", 开发者只需理解最基本的概念, 约束及严, 心智负担极低.

---

### 零信任原则

> **"任何可能出错的事情最终都会出错. "**

人类是有缺陷的, 我们不能依赖开发者的"自觉", "纪律"或"培训".

所以本框架做的事, 本质是:

- 强制检查: 系统尽可能是强类型的, 不会因为"照顾新人"降低对正确性的要求.
- 集中复杂度: 系统的复杂度不是平均的, 而是集中的, 资深开发者开发那些最复杂的部分, 换取其他部分的简单和严格约束.

---

## 🌠展望

让我们思考一种这样的开发模式:

- 核心开发者维护插件库/通用逻辑库, 并维护一个MCP服务供AI查询和调用.
- 初级开发者在简单学习后, 向AI描述具体业务, 让AI产出接口实现和测试.
  - 在复杂度不高, 同时拥有强类型检查的情况下, AI很容易编写这样的代码.
- 通过初级开发者反馈, 核心开发者新增合理的插件/通用逻辑, 让AI有更多选择.

这会是一个正向循环, 不但能快速产出可用的接口, 同时还能累计逻辑资产. 让这个过程更可靠更快速.
